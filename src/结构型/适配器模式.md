# 适配器模式实战：游戏输入设备统一

## 🧩 设计原理
适配器模式的核心思想是：将一个类的接口转换成客户端期望的另一个接口，解决接口不兼容问题。它就像现实世界中的电源转换器，让不同规格的设备能协同工作。

## 🎮 核心场景
游戏开发中需要同时支持**手柄**和**键盘**输入，但希望游戏逻辑使用**统一接口**调用，避免设备差异带来的复杂性。

## 🧩 解决方案
使用适配器模式创建**输入转换层**

## 🕹️ 精简代码实现（C++23）

```cpp
// 统一接口
class 游戏控制器 {
public:
    virtual bool 前进() = 0;
    virtual bool 攻击() = 0;
    virtual bool 跳跃() = 0;
};

// 手柄适配器
class 手柄适配器 : public 游戏控制器 {
    const 游戏手柄* 手柄;
public:
    explicit 手柄适配器(const 游戏手柄* h) : 手柄(h) {}
    bool 前进() override { return 手柄->左摇杆上推(); }
    bool 攻击() override { return 手柄->A键按下(); }
    bool 跳跃() override { return 手柄->B键按下(); }
};

// 键盘适配器
class 键盘适配器 : public 游戏控制器 {
    const 键盘* 键盘设备;
public:
    explicit 键盘适配器(const 键盘* k) : 键盘设备(k) {}
    bool 前进() override { return 键盘设备->W键按下(); }
    bool 攻击() override { return 键盘设备->J键按下(); }
    bool 跳跃() override { return 键盘设备->K键按下(); }
};

// 游戏引擎使用示例
游戏引擎 引擎;
游戏手柄 手柄;
键盘 键盘设备;

手柄适配器 手柄输入(&手柄);
键盘适配器 键盘输入(&键盘);

// 游戏循环中
引擎.处理输入(&手柄输入);  // 无缝切换设备
// 或 engine.process_input(&keyboard_input);
```

## 💡 核心价值

1. **接口统一化**  
   游戏逻辑只需调用`前进()/攻击()/跳跃()`，无需关心设备细节

2. **设备无关性**  
   添加新设备只需创建新适配器，不修改游戏引擎

3. **运行时切换**  
   支持游戏过程中动态切换输入设备

4. **代码解耦**  
   输入检测与游戏逻辑完全分离

## ⚙️ 两种实现方式对比

| **特性**       | **类适配器（继承）** | **对象适配器（组合）** |
|----------------|-------------------|---------------------|
| 实现机制       | 多重继承          | 对象组合            |
| 灵活性         | 较低              | **高**             |
| 适配多个类     | 困难              | **容易**           |
| 推荐度         | ★★☆☆☆            | **★★★★★**         |

## 🚀 实际应用

```cpp
// 扩展示例：手机触屏适配器
class 触屏适配器 : public 游戏控制器 {
    const 触摸屏* 触摸设备;
public:
    bool 前进() override { return 触摸设备->检测上滑(); }
    bool 攻击() override { return 触摸设备->点击区域(1); }
    bool 跳跃() override { return 触摸设备->点击区域(2); }
};

// 配置示例：自定义按键映射
class 自定义适配器 : public 游戏控制器 {
    std::map<操作类型, 按键> 映射表;
public:
    void 配置(操作类型 操作, 按键 键) {
        映射表[操作] = 键;
    }
    bool 前进() override { return 键盘::检测按键(映射表[前进]); }
};
```

## ⚠️ 关键注意事项

1. **保持适配器轻量** - 只做接口转换
2. **目标接口要稳定** - 避免频繁修改
3. **优先使用组合** - 更灵活可扩展
4. **避免多层嵌套** - 防止过度设计

> **适配器精髓**：不是改变设备本身，而是创建**翻译层**让不同设备说同一种"语言"

## 💎 总结

适配器模式是解决**接口不兼容**问题的利器，特别适合：
- 游戏多输入设备支持
- 新旧系统整合
- 第三方库接入
- 跨平台开发

通过创建中间适配层，实现**设备多样化**与**逻辑统一化**的完美平衡！
