# 结构型设计模式整理与扩展

## 1. 适配器模式 (Adapter Pattern)
**定义**：将一个类的接口转换成客户端期望的另一个接口，解决接口不兼容问题  
**核心思想**：通过中间层（适配器）进行接口转换  
**应用场景**：
- 整合第三方库或遗留系统
- 复用现有类但接口不匹配时
- 创建统一接口对接多个实现类  
**关键点**：
- 类适配器（通过继承） vs 对象适配器（通过组合）
- 适配器需实现目标接口并持有被适配对象的引用
- 示例：不同国家电源插头转换器、日志框架统一接口封装

---

## 2. 桥接模式 (Bridge Pattern)
**定义**：将抽象部分与实现部分分离，使二者可独立变化  
**核心思想**：使用组合替代多层继承  
**应用场景**：
- 多维度扩展（如形状×颜色）
- 避免类爆炸问题
- 运行时切换实现  
**关键点**：
- 抽象层包含对实现层的引用
- 抽象扩展不影响实现扩展
- 示例：GUI开发中（窗口抽象×操作系统实现）、支付系统（支付方式×支付渠道）

---

## 3. 组合模式 (Composite Pattern)
**定义**：将对象组织成树形结构以表示"部分-整体"层次关系  
**核心思想**：统一处理叶子节点和复合节点  
**应用场景**：
- 文件系统（文件/文件夹）
- UI组件树（按钮/容器）
- 组织架构管理  
**关键点**：
- 组件接口声明通用操作
- 复合节点包含子组件集合
- 透明式（统一接口）vs 安全式（分离接口）
- 示例：菜单系统（菜单项/子菜单）、XML文档解析

---

## 4. 装饰器模式 (Decorator Pattern)
**定义**：动态地为对象添加额外职责，避免静态继承  
**核心思想**：通过嵌套包装扩展功能  
**应用场景**：
- 扩展对象功能而不影响同类对象
- 撤销添加的功能
- 避免子类膨胀  
**关键点**：
- 装饰器与被装饰对象实现相同接口
- 支持多层嵌套装饰
- 示例：Java I/O流（BufferedInputStream）、咖啡加料系统

---

## 5. 外观模式 (Facade Pattern)
**定义**：为复杂子系统提供统一的高层接口  
**核心思想**：简化客户端调用复杂度  
**应用场景**：
- 封装遗留系统
- 降低模块间耦合度
- 提供易用的API层  
**关键点**：
- 外观类了解子系统各组件职责
- 客户端只与外观对象交互
- 示例：编译器前端（词法/语法/语义分析封装）、智能家居控制中枢

---

## 6. 享元模式 (Flyweight Pattern)
**定义**：通过共享技术高效支持大量细粒度对象  
**核心思想**：分离对象的内蕴状态（共享）和外蕴状态（外部管理）  
**应用场景**：
- 大量相似对象导致内存开销过大
- 对象状态可分内部/外部
- 需要缓存可共享对象  
**关键点**：
- 享元工厂管理对象池
- 外部状态由客户端维护
- 示例：文字编辑器（字符对象池）、游戏开发（粒子系统）

---

## 7. 代理模式 (Proxy Pattern)
**定义**：为其他对象提供代理以控制对该对象的访问  
**核心思想**：通过中间层添加间接层  
**应用场景**：
- 延迟加载（虚拟代理）
- 访问控制（保护代理）
- 远程对象调用（远程代理）  
**关键点**：
- 代理与真实对象实现相同接口
- 代理控制对真实对象的访问
- 示例：Spring AOP、图片懒加载、API网关
