#include <format> // æ·»åŠ  format å¤´æ–‡ä»¶
#include <memory>
#include <print>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector> // æ·»åŠ  vector å¤´æ–‡ä»¶

struct vec2 {
  int x, y;
};

class è´´å›¾ {
public:
  virtual void ç»˜åˆ¶(vec2 ä½ç½®) = 0;
  virtual ~è´´å›¾() = default; // æ·»åŠ è™šææ„å‡½æ•°ç¡®ä¿æ­£ç¡®é‡Šæ”¾èµ„æº
};

class ç«ç„°è´´å›¾ : public è´´å›¾ {
public:
  std::string æŒæœ‰çš„è´´å›¾;
  ç«ç„°è´´å›¾() : æŒæœ‰çš„è´´å›¾("ğŸ”¥ç«ç„°è´´å›¾") {}

  void ç»˜åˆ¶(vec2 ä½ç½®) override {
    std::println("æŒæœ‰çš„è´´å›¾:{};ä½ç½®:x {} y {}", æŒæœ‰çš„è´´å›¾, ä½ç½®.x, ä½ç½®.y);
  }
};

class å¯’å†°è´´å›¾ : public è´´å›¾ {
public:
  std::string æŒæœ‰çš„è´´å›¾1;
  std::string æŒæœ‰çš„è´´å›¾2;
  å¯’å†°è´´å›¾() : æŒæœ‰çš„è´´å›¾1("ğŸ§Šå¯’å†°è´´å›¾1"), æŒæœ‰çš„è´´å›¾2("ğŸ§Šå¯’å†°è´´å›¾2") {}

  void ç»˜åˆ¶(vec2 ä½ç½®) override {
    std::println("æŒæœ‰çš„è´´å›¾:{};ä½ç½®:x {} y {}", æŒæœ‰çš„è´´å›¾1, ä½ç½®.x, ä½ç½®.y);
    std::println("æŒæœ‰çš„è´´å›¾:{};ä½ç½®:x {} y {}", æŒæœ‰çš„è´´å›¾2, ä½ç½®.x, ä½ç½®.y);
  }
};

class è´´å›¾å·¥å‚ {
private:
  static std::unordered_map<std::string, std::shared_ptr<è´´å›¾>> è´´å›¾æ˜ å°„;

public:
  static std::shared_ptr<è´´å›¾> è·å–è´´å›¾(const std::string &ç±»å‹) {
    auto it = è´´å›¾æ˜ å°„.find(ç±»å‹);
    if (it != è´´å›¾æ˜ å°„.end()) {
      return it->second;
    }

    // åŠ¨æ€åˆ›å»ºæ–°è´´å›¾ç±»å‹
    std::shared_ptr<è´´å›¾> æ–°è´´å›¾;
    if (ç±»å‹ == "ç«ç„°") {
      æ–°è´´å›¾ = std::make_shared<ç«ç„°è´´å›¾>();
    } else if (ç±»å‹ == "å¯’å†°") {
      æ–°è´´å›¾ = std::make_shared<å¯’å†°è´´å›¾>();
    } else {
      throw std::runtime_error("æœªçŸ¥çš„è´´å›¾ç±»å‹: " + ç±»å‹);
    }

    è´´å›¾æ˜ å°„[ç±»å‹] = æ–°è´´å›¾;
    return æ–°è´´å›¾;
  }
};

// é™æ€æˆå‘˜åˆå§‹åŒ–
std::unordered_map<std::string, std::shared_ptr<è´´å›¾>> è´´å›¾å·¥å‚::è´´å›¾æ˜ å°„;

// å­å¼¹ç±»ä½¿ç”¨äº«å…ƒè´´å›¾
class å­å¼¹ {
private:
  vec2 ä½ç½®;
  vec2 é€Ÿåº¦;
  std::shared_ptr<è´´å›¾> ç²¾çµ;

public:
  å­å¼¹(vec2 åˆå§‹ä½ç½®, vec2 åˆå§‹é€Ÿåº¦, const std::string &è´´å›¾ç±»å‹)
      : ä½ç½®(åˆå§‹ä½ç½®), é€Ÿåº¦(åˆå§‹é€Ÿåº¦), ç²¾çµ(è´´å›¾å·¥å‚::è·å–è´´å›¾(è´´å›¾ç±»å‹)) {}

  void æ›´æ–°() {
    ä½ç½®.x += é€Ÿåº¦.x;
    ä½ç½®.y += é€Ÿåº¦.y;
  }

  void ç»˜åˆ¶() {
    if (ç²¾çµ) {
      ç²¾çµ->ç»˜åˆ¶(ä½ç½®);
    }
  }
};

int main() {
  try {
    // åˆ›å»ºå…±äº«è´´å›¾çš„å­å¼¹å¯¹è±¡
    std::vector<å­å¼¹> å­å¼¹åˆ—è¡¨;

    // åˆ›å»ºç«ç„°å­å¼¹
    for (int i = 0; i < 3; i++) {
      å­å¼¹åˆ—è¡¨.emplace_back(vec2{i * 10, 0}, vec2{1, 1}, "ç«ç„°");
    }

    // åˆ›å»ºå¯’å†°å­å¼¹
    for (int i = 0; i < 2; i++) {
      å­å¼¹åˆ—è¡¨.emplace_back(vec2{0, i * 20}, vec2{-1, 0}, "å¯’å†°");
    }

    // æ›´æ–°å¹¶ç»˜åˆ¶æ‰€æœ‰å­å¼¹
    std::println("===== åˆå§‹çŠ¶æ€ =====");
    for (auto &å­å¼¹å¯¹è±¡ : å­å¼¹åˆ—è¡¨) {
      å­å¼¹å¯¹è±¡.ç»˜åˆ¶();
    }

    // æ›´æ–°ä½ç½®åå†æ¬¡ç»˜åˆ¶
    std::println("\n===== æ›´æ–°åçŠ¶æ€ =====");
    for (auto &å­å¼¹å¯¹è±¡ : å­å¼¹åˆ—è¡¨) {
      å­å¼¹å¯¹è±¡.æ›´æ–°();
      å­å¼¹å¯¹è±¡.ç»˜åˆ¶();
    }

    // æµ‹è¯•äº«å…ƒæ•ˆæœ - å†æ¬¡è·å–ç›¸åŒè´´å›¾
    std::println("\n===== æµ‹è¯•äº«å…ƒæ•ˆæœ =====");
    auto å…±äº«ç«ç„°è´´å›¾ = è´´å›¾å·¥å‚::è·å–è´´å›¾("ç«ç„°");
    auto å…±äº«å¯’å†°è´´å›¾ = è´´å›¾å·¥å‚::è·å–è´´å›¾("å¯’å†°");

    // å†…å­˜åœ°å€ç›¸åŒè¯æ˜æ˜¯åŒä¸€ä¸ªå¯¹è±¡
    std::println("ç«ç„°è´´å›¾åœ°å€: {}", static_cast<void *>(å…±äº«ç«ç„°è´´å›¾.get()));
    std::println("å¯’å†°è´´å›¾åœ°å€: {}", static_cast<void *>(å…±äº«å¯’å†°è´´å›¾.get()));

    // æµ‹è¯•æœªçŸ¥ç±»å‹å¼‚å¸¸
    // auto æœªçŸ¥è´´å›¾ = è´´å›¾å·¥å‚::è·å–è´´å›¾("æœªçŸ¥"); // å°†æŠ›å‡ºå¼‚å¸¸

  } catch (const std::exception &e) {
    std::println("é”™è¯¯: {}", e.what());
  }

  return 0;
}
