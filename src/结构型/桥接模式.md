# 桥接模式（Bridge Pattern）

## 🌉 什么是桥接模式？
**将抽象与实现分离**，使它们可以独立变化的设计模式。就像在抽象和实现之间架起一座桥，让两边可以独立发展而不互相影响。

## 🧩 解决什么问题？
当系统有**多个变化维度**时，避免使用多层继承导致的**类爆炸**问题：
- 形状类型：圆形、矩形、三角形...
- 渲染方式：OpenGL、DirectX、Vulkan...
- 传统继承：每增加一种形状+渲染组合就需要一个新类（3形状×3渲染=9个类）
- 桥接模式：只需3(形状)+3(渲染)=6个类

## 🎯 核心思想
**组合优于继承**：将变化的部分抽离成独立层次，通过组合关系连接

## 📐 结构图解
```
     抽象部分(Abstraction)       ───────桥接───────>      实现部分(Implementor)
          │                                               │
          ├─ 扩展抽象(RefinedAbstraction)                 ├─ 具体实现A(ConcreteImplementorA)
          └─ 扩展抽象(RefinedAbstraction)                 └─ 具体实现B(ConcreteImplementorB)
```

## 💻 代码示例（伪代码）
```cpp
// 实现部分接口
class 渲染器 {
public:
    virtual void 渲染(形状) = 0;
}

// 具体实现
class OpenGL渲染器 : public 渲染器 {
    void 渲染(形状) { /* OpenGL渲染逻辑 */ }
}

class DirectX渲染器 : public 渲染器 {
    void 渲染(形状) { /* DirectX渲染逻辑 */ }
}

// 抽象部分
class 形状 {
protected:
    渲染器* 渲染器; // 关键：持有实现部分引用
    
public:
    形状(渲染器* 渲染器) : 渲染器(渲染器) {}
    virtual void 绘制() = 0;
}

// 扩展抽象
class 圆形 : public 形状 {
    void 绘制() { 
        渲染器->渲染(圆形); // 委托给实现部分
    }
}

// 使用
void main() {
    渲染器* dx渲染器 = new DirectX渲染器();
    形状* 圆形 = new 圆形(dx渲染器); // 组合抽象和实现
    圆形->绘制(); // 输出: DirectX渲染圆形
}
```

## ✅ 五大优点
1. **解耦抽象与实现**：修改渲染器不影响形状类
2. **扩展性极强**：
   - 新增形状只需扩展抽象部分
   - 新增渲染引擎只需扩展实现部分
3. **避免类爆炸**：M种抽象 + N种实现 → 只需 M+N 个类
4. **运行时切换实现**：动态更换渲染引擎
5. **符合开闭原则**：新增功能无需修改已有代码

## 🚀 适用场景
| 场景 | 示例 |
|------|------|
| 多维度变化 | 图形+渲染器、设备+遥控器 |
| 运行时切换实现 | 游戏切换渲染引擎 |
| 避免多层继承 | 形状继承体系过于复杂 |
| 跨平台开发 | Windows/Mac/Linux 不同实现 |
| 驱动开发 | 统一接口支持不同硬件 |

## 🔍 与适配器模式对比
|          | 桥接模式                     | 适配器模式               |
|----------|------------------------------|--------------------------|
| **目的** | 设计时分离抽象与实现         | 使不兼容接口协同工作     |
| **时机** | 系统设计阶段                 | 已有系统改造时           |
| **关系** | 抽象和实现是平行关系         | 适配器是中间转换层       |
| **变化** | 主动设计多个维度独立变化     | 被动适配已有接口         |

## 💡 总结
> **"不要继承一切，组合更灵活"**  
> 当系统在多个维度变化时，使用桥接模式解耦抽象与实现，  
> 让每个维度可以独立扩展，避免类数量爆炸式增长。

