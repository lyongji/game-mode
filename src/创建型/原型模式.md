# 原型模式 (Prototype Pattern) 总结

## 模式定义
原型模式是一种**创建型设计模式**，它允许通过复制现有对象来创建新对象，而无需知道具体的创建细节。这种模式的核心思想是将对象自身变成自己的工厂。

## 问题解决
当满足以下情况时，原型模式特别有用：
1. 对象创建成本高昂（如需要复杂初始化或资源加载）
2. 系统需要独立于其产品的创建、组合和表示方式
3. 需要避免构建与产品类平行的工厂类层次结构
4. 类在运行时指定时才实例化

## 实现关键

### 1. 原型接口
```cpp
class 球 {
public:
  virtual ~球() = default;  // 必须的虚析构函数
  virtual std::unique_ptr<球> 克隆() const = 0;  // 克隆方法
};
```

- 定义了一个抽象基类`球`，其中包含一个纯虚函数`克隆`，返回一个`unique_ptr<球>`。
- 虚析构函数确保通过基类指针删除派生类对象时行为正确。

### 2. CRTP实现（自动克隆）
```cpp
template <class 子类> 
class 球接口 : public 球 {
public:
  std::unique_ptr<球> 克隆() const override {
    const 子类 *子类实例 = static_cast<const 子类*>(this);
    return std::make_unique<子类>(*子类实例);  // 调用复制构造函数
  }
};
```

- 这个模板类继承自`球`，并实现了`克隆`方法。
- 在`克隆`方法中，将当前对象（基类指针）转换为具体的派生类类型（通过CRTP，模板参数`子类`就是派生类类型），然后通过复制构造函数创建一个新的派生类对象，并返回其基类指针。
- 使用CRTP的好处是，我们可以将克隆方法的实现复用给所有派生类，而不需要在每个派生类中重复实现。

### 3. 具体原型实现
```cpp
class 火焰球 : public 球接口<火焰球> {
public:
  int 温度{100};  // 成员变量会被自动复制
  
  // 无需手动实现克隆方法 - CRTP自动提供
};
```

- `爆炸球`和`火焰球`都通过继承`球接口`并传入自身作为模板参数，自动获得了克隆方法。
- 在`火焰球`中有一个成员变量`温度`，当我们调用克隆方法时，会调用`火焰球`的复制构造函数，从而复制该成员的值。

### 4. 客户端使用
```cpp
int main() {
  火焰球 火球;
  auto 火球2 = 火球.克隆();
  std::println("{}", 火球.温度); // 输出原对象的温度
  // 可以通过dynamic_cast将基类指针转换为火焰球指针来访问温度
  if (auto 火球2指针 = dynamic_cast<火焰球*>(火球2.get())) {
    std::println("{}", 火球2指针->温度); // 输出100
  }
}
```

- 在`main`函数中，我们创建了一个`火焰球`对象`火球`。
- 然后通过调用`火球.克隆()`创建了一个新的`火焰球`对象，该对象是`火球`的副本。
- 由于`火球2`的类型是`std::unique_ptr<球>`，我们需要通过`dynamic_cast`将其转换为`火焰球*`来访问派生类特有的成员（如`温度`）。

## 模式优势

1. **减少创建开销**：
   - 避免重复执行昂贵的初始化操作
   - 复用现有对象的状态

2. **简化对象创建**：
   - 客户端无需知道具体类名
   - 消除工厂类的需要

3. **动态配置系统**：
   - 在运行时添加或删除产品
   - 通过克隆改变配置

4. **减少子类数量**：
   - 不需要为每种对象创建专门的工厂

5. **类型安全**：
   - 通过CRTP确保正确的克隆实现

## 使用场景

1. **游戏开发**：
   - 快速创建相似的游戏实体（如子弹、敌人）
   - 复制复杂状态的对象

2. **图形编辑**：
   - 复制图形元素（形状、图层）
   - 实现撤销/重做功能

3. **数据库操作**：
   - 复制具有复杂查询条件的对象
   - 创建相似查询模板

4. **配置管理**：
   - 基于现有配置创建新配置
   - 实现配置模板

## 注意事项

1. **深拷贝与浅拷贝**：
   - 确保复制构造函数正确处理指针成员
   - 需要深拷贝时实现自定义复制逻辑

2. **循环引用**：
   - 对象相互引用时可能导致克隆问题
   - 需要特殊处理相互引用的对象

3. **性能考量**：
   - 对于非常小的对象，直接创建可能比克隆更快
   - 评估克隆与初始化的成本比

## 示例代码对比

### 传统实现（无原型模式）
```cpp
class 火焰球 : public 球 {
public:
  std::unique_ptr<球> 克隆() const override {
    return std::make_unique<火焰球>(*this);  // 每个类都需要实现
  }
  // ... 其他成员 ...
};
```

### 原型模式实现（使用CRTP）
```cpp
class 火焰球 : public 球接口<火焰球> {
  // 无需实现克隆 - 自动继承
  // ... 其他成员 ...
};
```

## 总结

原型模式通过以下方式优化对象创建：
- ✅ 将对象自身作为创建模板
- ✅ 避免昂贵的初始化过程
- ✅ 减少子类和工厂类的数量
- ✅ 提供灵活的运行时对象创建

在C++中，结合CRTP实现原型模式可以：
- 自动生成克隆方法
- 确保类型安全
- 减少代码重复
- 提高编译时检查能力

原型模式特别适合需要创建大量相似对象或对象创建成本高昂的场景，是优化对象创建过程的有效工具。
