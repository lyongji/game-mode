行为型设计模式主要关注 **对象之间的职责分配和通信方式**，解决的是程序中对象之间如何协作、如何分配任务，以及如何让算法或行为更灵活、可复用的问题。

简单来说，它们管理的是 **“对象如何做事情”** 和 **“对象之间如何交互”**。

以下是常见行为型设计模式的简要概述：

1.  **模板方法模式**
    *   **核心思想：** 定义一个操作中的算法骨架（模板方法），将一些步骤延迟到子类中实现。子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。
    *   **类比：** 做菜的食谱（模板方法）规定了洗菜、切菜、炒菜、装盘的大步骤。不同的菜（子类）具体怎么洗、怎么切、怎么炒可以不同，但步骤顺序是固定的。
    *   **目的：** 代码复用，扩展点控制。

2.  **策略模式**
    *   **核心思想：** 定义一系列算法（策略），将每个算法封装起来，并使它们可以互相替换。让算法的变化独立于使用它的客户端。
    *   **类比：** 出行方式（策略）：飞机、火车、汽车。旅行者（客户端）可以根据预算或时间选择不同的出行方式，但旅行本身（调用策略的接口）不变。
    *   **目的：** 分离算法，避免多重条件判断，支持算法的灵活切换。

3.  **观察者模式**
    *   **核心思想：** 定义对象间的一种一对多的依赖关系，当一个对象（被观察者/主题）的状态发生改变时，所有依赖于它的对象（观察者）都会得到通知并自动更新。
    *   **类比：** 新闻出版社（主题）和订阅者（观察者）。新报纸出版（状态改变）时，所有订阅者都会收到报纸（被通知）。
    *   **目的：** 实现松耦合，当一个对象改变状态需要通知其他对象时。

4.  **责任链模式**
    *   **核心思想：** 将请求的发送者和接收者解耦。使多个对象都有机会处理该请求。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
    *   **类比：** 公司报销流程：员工提交报销单，先给组长审，组长不能处理（金额太大）就转给经理，经理不能处理再转给总监，直到有人能处理为止。
    *   **目的：** 解耦发送者和接收者，动态指定处理者，允许多个对象处理请求。

5.  **命令模式**
    *   **核心思想：** 将“请求”封装成一个对象（命令对象），以便使用不同的请求、队列或日志来参数化其他对象（调用者）。同时支持请求的撤销/重做。
    *   **类比：** 餐厅订单：顾客（客户端）点菜（创建命令对象）交给服务员（调用者），服务员把订单（命令对象）交给厨师（接收者）执行。订单本身封装了“做什么菜”的请求。
    *   **目的：** 解耦请求发送者和执行者，将请求参数化、队列化、日志化，支持撤销/重做。

6.  **状态模式**
    *   **核心思想：** 允许一个对象在其内部状态改变时改变它的行为。这个对象看起来像是修改了它的类。
    *   **类比：** 电灯开关：有“开”和“关”两种状态。按同一个按钮（行为），在“开”状态下会关灯，在“关”状态下会开灯。行为随内部状态变化。
    *   **目的：** 将与特定状态相关的行为局部化，并且让状态转换显式化，减少条件分支。

7.  **访问者模式**
    *   **核心思想：** 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
    *   **类比：** 保险推销员（访问者）访问不同家庭（元素）：家庭A、家庭B、家庭C。推销员可以根据家庭类型（元素类型）提供不同的保险方案（新操作），而不需要修改家庭类本身。
    *   **目的：** 将数据结构与数据操作分离，便于添加新的操作，集中相关操作。

8.  **中介者模式**
    *   **核心思想：** 定义一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    *   **类比：** 机场控制塔（中介者）。不同飞机（对象）之间不直接通信，而是都与控制塔通信，由控制塔协调它们的起飞、降落、航线，避免相撞。
    *   **目的：** 减少对象间混乱的网状引用，将多对多交互简化为一对多（中介者与各个对象）。

9.  **迭代器模式**
    *   **核心思想：** 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
    *   **类比：** 遥控器（迭代器）遍历电视频道（聚合对象的元素）。你不需要知道电视台内部如何存储频道列表，按遥控器的“下一个”按钮就能遍历。
    *   **目的：** 简化对聚合对象的遍历，隐藏内部结构。

10. **备忘录模式**
    *   **核心思想：** 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态（备忘录）。以后就可将该对象恢复到原先保存的状态。
    *   **类比：** 游戏存档（备忘录）。游戏（原发器）在某个时刻保存当前状态（创建备忘录），之后如果游戏失败，可以读取存档（备忘录）恢复到之前的状态。
    *   **目的：** 提供状态恢复机制，支持撤销操作。

11. **解释器模式**
    *   **核心思想：** 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    *   **类比：** 翻译器。它理解一种特定语言（如 SQL 查询语句）的语法规则（文法），并能根据这些规则解释执行语句（如执行查询）。
    *   **目的：** 为特定领域设计一种语言并解释执行它（通常用于编译器、规则引擎、正则表达式等）。

**总结一下行为型模式的核心目标：**

*   **解耦：** 让对象之间的依赖关系更清晰、更松散（观察者、中介者、命令）。
*   **复用与扩展：** 提高算法或行为的复用性，方便扩展（模板方法、策略、访问者）。
*   **管理复杂交互：** 简化对象间复杂的通信流程（责任链、中介者）。
*   **封装变化：** 将容易变化的部分（如状态、算法）独立出来，减少对其他代码的影响（状态、策略）。
*   **控制流程：** 管理对象集合的遍历（迭代器），对象状态的保存与恢复（备忘录），甚至定义新的语言规则（解释器）。

