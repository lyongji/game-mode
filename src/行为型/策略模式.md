# 游戏开发中的策略模式详解

## 什么是策略模式？
策略模式（Strategy Pattern）是一种**行为设计模式**，它定义了一系列算法，并将每个算法封装起来，使它们可以**相互替换**。策略模式让算法的变化独立于使用算法的客户端。

### 核心思想
- **封装变化**：将经常变化的部分（算法/行为）独立出来
- **面向接口编程**：通过接口定义算法族
- **组合优于继承**：使用组合方式动态切换行为

## 策略模式的核心组件
| 组件 | 角色 | 描述 |
|------|------|------|
| **策略接口** | Strategy | 定义所有支持的算法的公共接口 |
| **具体策略** | Concrete Strategy | 实现策略接口的具体算法类 |
| **上下文** | Context | 持有一个策略对象的引用，通过策略接口与之交互 |



## 策略模式在游戏开发中的优势

1. **开闭原则**：
   - 添加新策略无需修改现有代码
   - 只需实现新的策略类并注入到上下文中

2. **消除条件语句**：
   ```cpp
   // 不使用策略模式（糟糕的实现）
   void 执行攻击(攻击类型 类型) {
       switch(类型) {
           case 近战: // ... 
           case 远程: // ...
           case 魔法: // ...
       }
   }
   ```

3. **运行时切换行为**：
   - 角色可以动态改变攻击策略
   - 实现武器切换系统
   - 支持角色技能变化

4. **算法复用**：
   - 相同策略可用于不同角色
   - 如多个角色共享"远程攻击"策略

## 游戏开发应用场景

### 1. AI行为系统
```cpp
class AI行为策略 {
public:
    virtual void 更新行为(游戏角色& 角色) = 0;
};

class 巡逻策略 : public AI行为策略 {
    void 更新行为(游戏角色& 角色) override {
        // 巡逻逻辑
    }
};

class 追击策略 : public AI行为策略 {
    void 更新行为(游戏角色& 角色) override {
        // 追击玩家逻辑
    }
};

class 逃跑策略 : public AI行为策略 {
    void 更新行为(游戏角色& 角色) override {
        // 低血量逃跑逻辑
    }
};
```

### 2. 移动系统
```cpp
class 移动策略 {
public:
    virtual void 移动(游戏角色& 角色) = 0;
};

class 行走策略 : public 移动策略 {
    void 移动(游戏角色& 角色) override {
        // 行走逻辑
    }
};

class 奔跑策略 : public 移动策略 {
    void 移动(游戏角色& 角色) override {
        // 奔跑逻辑（消耗耐力）
    }
};

class 飞行策略 : public 移动策略 {
    void 移动(游戏角色& 角色) override {
        // 飞行逻辑（无视地形）
    }
};
```

### 3. 伤害计算系统
```cpp
class 伤害计算策略 {
public:
    virtual int 计算伤害(攻击者&, 防御者&) = 0;
};

class 物理伤害计算 : public 伤害计算策略 {
    int 计算伤害(攻击者& 攻, 防御者& 防) override {
        return 攻.攻击力 - 防.物理防御;
    }
};

class 魔法伤害计算 : public 伤害计算策略 {
    int 计算伤害(攻击者& 攻, 防御者& 防) override {
        return 攻.魔法强度 * 2 - 防.魔法抗性;
    }
};

class 真实伤害计算 : public 伤害计算策略 {
    int 计算伤害(攻击者& 攻, 防御者&) override {
        return 攻.真实伤害值; // 无视防御
    }
};
```

## 对比 

| 特性         | 策略模式                     | 状态模式                         | 命令模式                           |
|--------------|------------------------------|----------------------------------|------------------------------------|
| **核心目的** | 封装可互换的算法             | 管理对象的状态转换               | 将请求封装为对象                   |
| **主要关注** | 行为的选择                   | 状态的生命周期                   | 请求的封装和管理                   |
| **切换方式** | 客户端主动切换               | 状态内部自动转换或外部事件触发   | 由调用者触发执行                   |
| **组件关系** | 策略间无关联                 | 状态间相互了解                   | 命令与接收者解耦                   |
| **典型应用** | AI行为、伤害计算、渲染策略   | 角色状态、游戏流程               | 撤销/重做、命令队列、宏命令        |
| **状态感知** | 策略无状态或状态无关         | 状态有内部状态                   | 命令可包含状态（支持撤销）         |
| **变化频率** | 算法相对稳定                 | 状态频繁转换                     | 请求执行时机灵活                   |

## 策略模式最佳实践

1. **策略对象共享**：
   - 对于无状态的策略，可共享实例
   ```cpp
   static auto& 获取近战策略() {
       static 近战攻击 实例;
       return 实例;
   }
   ```

2. **策略工厂**：
   ```cpp
   class 策略工厂 {
   public:
       std::unique_ptr<攻击策略> 创建策略(策略类型 类型) {
           switch(类型) {
               case 策略类型::近战: return std::make_unique<近战攻击>();
               case 策略类型::远程: return std::make_unique<远程攻击>();
               case 策略类型::魔法: return std::make_unique<魔法攻击>();
               default: return nullptr;
           }
       }
   };
   ```

3. **策略组合**：
   ```cpp
   class 组合策略 : public 攻击策略 {
   public:
       void 添加策略(std::unique_ptr<攻击策略> 策略) {
           策略列表.push_back(std::move(策略));
       }
       
       void 执行攻击() const override {
           for (auto& 策略 : 策略列表) {
               策略->执行攻击();
           }
       }
   
   private:
       std::vector<std::unique_ptr<攻击策略>> 策略列表;
   };
   ```

4. **策略参数化**：
   ```cpp
   class 自定义伤害攻击 : public 攻击策略 {
   public:
       explicit 自定义伤害攻击(int 伤害值) : 伤害(伤害值) {}
       
       void 执行攻击() const override {
           std::cout << "自定义攻击！造成" << 伤害 << "点伤害\n";
       }
   
   private:
       int 伤害;
   };
   ```

## 如何选择合适的设计模式

1. **选择策略模式当**：
   - 需要多种算法变体
   - 算法相对独立且不频繁变化
   - 需要在运行时切换算法
   - 示例：渲染策略、伤害计算

2. **选择状态模式当**：
   - 对象行为取决于其状态
   - 状态转换逻辑复杂
   - 需要避免大量的条件语句
   - 示例：角色状态机、游戏流程

3. **选择命令模式当**：
   - 需要实现撤销/重做功能
   - 需要将操作排队或延迟执行
   - 需要支持宏命令或事务
   - 示例：输入处理、编辑历史


在游戏开发中，策略模式、状态模式和命令模式**常常协同工作**：

1. **状态模式**管理对象的状态生命周期
2. **策略模式**决定每个状态下使用的算法
3. **命令模式**封装具体的操作请求

这种组合可以创建高度灵活、可维护的游戏系统架构：
- 状态机控制整体流程
- 策略模式提供行为变体
- 命令模式实现具体操作和撤销机制


## 总结

策略模式是游戏开发中**强大的设计工具**，特别适合以下场景：
- 一个系统需要多种算法变体
- 需要在运行时切换算法
- 需要隔离算法实现和使用细节
- 存在大量条件语句选择不同行为

通过使用策略模式，您可以：
1. 创建灵活可扩展的游戏系统
2. 降低代码耦合度
3. 提高代码可测试性
4. 支持动态行为切换
5. 实现"即插即用"的游戏机制

在游戏开发中，策略模式广泛用于AI系统、战斗系统、移动机制、伤害计算等场景，是构建模块化、可维护游戏架构的关键技术之一。
