### 中介者模式（Mediator Pattern）详解

#### 模式定义
**中介者模式**用一个中介对象来封装一系列对象之间的交互。该模式通过减少对象之间显式引用，使对象间耦合度降低，从而更易于独立修改和复用。

#### 适用场景
- 对象之间存在复杂的网状引用关系
- 需要集中控制多个对象间的交互
- 系统组件需要可复用，但直接引用导致耦合度过高

---

### 游戏聊天大厅示例
#### 场景描述
假设我们有一个游戏聊天大厅：
1. 多个玩家（`玩家类`）可以加入大厅
2. 玩家可以发送消息到大厅
3. 大厅负责将消息广播给所有玩家
4. 玩家之间不直接通信，必须通过大厅中介



---

### 模式优势
1. **解耦对象关系**：玩家间无直接引用，仅依赖中介者
2. **简化对象协议**：通信协议集中在中介者中维护
3. **控制集中化**：消息路由逻辑集中在聊天大厅
4. **扩展性增强**：新增玩家只需注册到中介者

#### 对比直接通信
| **直接通信** | **中介者模式** |
|-------------|---------------|
| N*(N-1)个连接 | 仅N个连接 |
| 修改影响多个对象 | 修改隔离在中介者内 |

---

### 关键实现点
1. **中介者接口**：定义对象间的通信协议
2. **具体中介者**：实现协调逻辑（如消息广播）
3. **同事类**：持有中介者引用而非其他同事对象
4. **注册机制**：中介者需知晓所有同事对象

> **注意**：当中介者逻辑过于复杂时，可能成为"上帝对象"，此时需考虑拆分中介者职责或引入层次化中介者结构。

### 中介者模式扩展：聊天大厅的进阶功能

在游戏聊天大厅中，中介者模式可以支持更丰富的交互场景。以下是聊天大厅可能实现的进阶功能：

#### 1. 私聊系统
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    // ... 其他代码 ...
    void 发送私聊(const 玩家类* 发送者, 
                const std::string& 接收者名称, 
                const std::string& 消息) override 
    {
        auto 接收者 = 查找玩家(接收者名称);
        if (接收者) {
            接收者->接收(发送者, 消息, true); // true 表示私聊
        } else {
            // 离线消息处理
            离线消息存储[接收者名称].push_back({发送者->获取名称(), 消息});
        }
    }
private:
    std::unordered_map<std::string, std::vector<std::pair<std::string, std::string>>> 离线消息存储;
};
```

#### 2. 频道管理
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    void 创建频道(const std::string& 频道名称) {
        频道映射表[频道名称] = std::make_unique<频道类>(频道名称);
    }

    void 加入频道(const std::string& 玩家名称, const std::string& 频道名称) {
        if (auto 频道 = 频道映射表.find(频道名称); 频道 != 频道映射表.end()) {
            频道->second->添加玩家(查找玩家(玩家名称));
        }
    }

    void 广播到频道(const 玩家类* 发送者, 
                   const std::string& 频道名称, 
                   const std::string& 消息) 
    {
        if (auto 频道 = 频道映射表.find(频道名称); 频道 != 频道映射表.end()) {
            频道->second->广播消息(发送者, 消息);
        }
    }
private:
    class 频道类 {
    public:
        explicit 频道类(std::string 名称) : 频道名称(std::move(名称)) {}
        void 添加玩家(玩家类* 玩家) { 频道成员.push_back(玩家); }
        void 广播消息(const 玩家类* 发送者, const std::string& 消息) {
            for (auto 成员 : 频道成员) {
                if (成员 != 发送者) {
                    成员->接收(发送者, 消息, false, 频道名称);
                }
            }
        }
    private:
        std::string 频道名称;
        std::vector<玩家类*> 频道成员;
    };

    std::unordered_map<std::string, std::unique_ptr<频道类>> 频道映射表;
};
```

#### 3. 敏感词过滤
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    void 添加敏感词(const std::string& 敏感词) {
        敏感词列表.push_back(敏感词);
    }

    std::string 过滤消息(const std::string& 原始消息) {
        std::string 过滤后消息 = 原始消息;
        for (const auto& 敏感词 : 敏感词列表) {
            size_t 位置 = 0;
            while ((位置 = 过滤后消息.find(敏感词, 位置)) != std::string::npos) {
                过滤后消息.replace(位置, 敏感词.length(), "***");
                位置 += 3; // 跳过替换后的字符
            }
        }
        return 过滤后消息;
    }
private:
    std::vector<std::string> 敏感词列表;
};
```

#### 4. 消息历史记录
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    void 广播消息(const 玩家类* 发送者, const std::string& 消息) override {
        // 存储消息历史（保留最近100条）
        历史消息.push_back({发送者->获取名称(), 消息});
        if (历史消息.size() > 100) {
            历史消息.pop_front();
        }
        
        // ... 广播逻辑 ...
    }

    void 获取历史消息(玩家类* 玩家) {
        for (const auto& [发送者, 消息] : 历史消息) {
            玩家->接收(nullptr, "[" + 发送者 + "]: " + 消息, false);
        }
    }
private:
    std::deque<std::pair<std::string, std::string>> 历史消息;
};
```

#### 5. 玩家状态管理
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    void 注册玩家(玩家类* 玩家) override {
        玩家列表.push_back(玩家);
        玩家状态[玩家->获取名称()] = 玩家状态::在线;
        广播系统消息(玩家->获取名称() + " 加入了聊天室");
    }

    void 玩家离开(玩家类* 玩家) {
        玩家状态[玩家->获取名称()] = 玩家状态::离线;
        广播系统消息(玩家->获取名称() + " 离开了聊天室");
    }

    void 设置状态(const std::string& 玩家名称, 玩家状态 状态) {
        玩家状态[玩家名称] = 状态;
    }
private:
    enum class 玩家状态 { 在线, 忙碌, 离开, 离线 };
    std::unordered_map<std::string, 玩家状态> 玩家状态;
};
```

#### 6. 消息格式处理
```cpp
class 聊天大厅 : public 聊天中介者接口 {
public:
    void 广播消息(const 玩家类* 发送者, const std::string& 消息) override {
        std::string 格式化消息 = 格式化处理(消息);
        // ... 广播逻辑 ...
    }

private:
    std::string 格式化处理(const std::string& 消息) {
        // 转换URL为链接
        std::regex 链接正则(R"((https?://\S+))");
        return std::regex_replace(消息, 链接正则, R"(<a href="$1">$1</a>)");
    }
};
```



### 聊天大厅扩展功能总结

| 功能          | 实现要点                                          | 优势                                                |
|---------------|---------------------------------------------------|-----------------------------------------------------|
| **私聊系统**      | 通过玩家名称查找目标，支持离线消息存储            | 实现点对点精准通信，增强社交性                      |
| **频道管理**      | 创建独立频道对象，管理频道成员                    | 分流聊天内容，减少信息过载                          |
| **敏感词过滤**    | 消息广播前进行关键词替换                          | 维护聊天环境健康，符合监管要求                      |
| **消息历史记录**  | 使用双端队列存储历史消息，控制存储大小            | 新玩家快速融入，提供上下文参考                      |
| **玩家状态管理**  | 记录玩家在线状态，进出通知                        | 增强社交感知，了解其他玩家可用性                    |
| **消息格式化**    | 自动转换URL为链接，支持富文本                     | 提升消息可读性和交互性                              |
| **离线消息**      | 目标不在线时存储消息，上线后自动推送              | 确保重要消息不丢失，提升用户体验                    |
| **系统消息**      | 自动生成玩家进出通知                              | 增强社区氛围，提高玩家参与感                        |

### 设计考量

1. **性能优化**：
   - 使用哈希表存储玩家状态（O(1)查找）
   - 限制历史消息数量（防止内存无限增长）
   - 敏感词过滤使用字符串替换而非正则（提高效率）

2. **扩展性**：
   - 频道系统可扩展为分层结构（大厅→频道→子频道）
   - 敏感词过滤可扩展为插件系统（支持动态加载词库）
   - 消息处理流水线可扩展（过滤→格式化→分析→分发）

3. **安全性**：
   - 防止消息泛滥（添加速率限制）
   - 敏感词动态更新（无需重启服务）
   - 私聊消息加密传输（增强隐私保护）

4. **用户体验**：
   - 离线消息保证可达
   - 历史消息快速获取
   - 自动链接识别
   - 玩家状态可视化

中介者模式的核心优势在这些扩展中得到充分体现：所有交互逻辑集中在大厅中实现，玩家对象保持简洁，新增功能无需修改已有玩家类代码，符合开闭原则。
