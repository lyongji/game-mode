责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，允许你将请求沿着处理链传递，直到有一个处理者能够处理它为止。这种模式解耦了请求的发送者和接收者，让多个对象都有机会处理请求。
### 原理
想象一个流水线，每个工人（处理者）负责一项特定任务。当产品（请求）经过流水线时，每个工人检查自己是否能处理：
1. 如果能处理，就处理并停止传递。
2. 如果不能处理，就交给下一个工人。
3. 如果所有工人都处理不了，请求可能被丢弃或特殊处理。
在代码中：
- 定义一个**处理者接口**，包含处理请求的方法和设置下一个处理者的方法。
- 每个**具体处理者**实现接口，决定自己能否处理请求：
   - 能处理 → 处理请求。
   - 不能处理 → 转发给下一个处理者。
- 客户端将请求发送给链的第一个处理者，无需知道具体由谁处理。
### 优点
1. **解耦请求发送者和接收者**：发送者无需知道具体谁来处理请求。
2. **动态调整责任链**：可以运行时动态添加、删除或修改处理者顺序。
3. **增强灵活性**：分配职责更灵活，每个处理者只需关注自己的责任范围。
4. **符合开闭原则**：新增处理者无需修改现有代码，只需扩展链条。
### 缺点
1. **请求可能未被处理**：如果链条没有正确配置，请求可能到达链尾也没被处理。
2. **性能问题**：请求可能经过多个无效处理者才被处理，尤其在长链中。
3. **调试困难**：责任链是动态的，运行时行为不易跟踪，调试较复杂。
### 应用场景
1. **多条件请求处理**：例如审批流程（员工 → 经理 → CEO），每个审批人是一个处理者。
2. **事件处理系统**：如GUI中的事件冒泡（按钮 → 面板 → 窗口）。
3. **日志记录**：不同级别的日志（DEBUG → INFO → WARN → ERROR）由不同记录器处理。
4. **中间件管道**：Web框架的中间件（身份验证 → 日志 → 业务处理）。
5. **游戏系统**：如伤害计算（物理抗性处理者 → 魔法抗性处理者 → 最终伤害计算）。
### 通俗比喻
> **快递分拣系统**  
> 包裹（请求）从仓库发出，经过多个分拣站（处理者）：
> - 第一站：按省份分拣（只处理省份标签）。
> - 第二站：按城市分拣（只处理城市标签）。
> - 第三站：按街道分拣（处理街道标签）。
> 
> 每个分拣站只处理自己能识别的标签，无法处理就传给下一站。直到包裹到达正确的派送站，或被退回（未被处理）。
### 代码示例（简化的伪代码）
```cpp
// 处理者接口
class Handler {
public:
    virtual void handle(Request req) = 0;
    void setNext(Handler* next) { next_ = next; }
protected:
    Handler* next_;
};
// 具体处理者A
class ConcreteHandlerA : public Handler {
public:
    void handle(Request req) override {
        if (canHandle(req)) {
            // 处理请求
        } else if (next_ != nullptr) {
            next_->handle(req); // 传递给下一个
        }
    }
};
// 客户端使用
int main() {
    Handler* chain = new ConcreteHandlerA();
    chain->setNext(new ConcreteHandlerB());
    
    Request req;
    chain->handle(req); // 从链头开始处理
}
```
### 总结
责任链模式像**接力赛**：请求是接力棒，处理者是运动员。每个运动员只跑自己那一段，跑完交给下一位，直到有人冲线（处理成功）或掉棒（处理失败）。适合需要**多级处理**或**流程化处理**的场景，但要注意避免链条过长导致的性能损耗。
