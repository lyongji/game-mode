模板方法模式（Template Method Pattern）是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不改变结构的情况下重写算法的特定步骤。该模式的核心是将算法的不变部分（即模板方法）放在父类中实现，而将可变的部分留给子类去实现。
在游戏开发中，模板方法模式非常有用。例如，我们可以定义一个游戏角色的行为流程，如“准备战斗”、“执行战斗”和“结束战斗”三个步骤。其中，准备和结束战斗的步骤可能对所有角色都通用，但执行战斗的方式可能因角色而异。

*定义*：定义一个操作中的算法骨架，将某些步骤延迟到子类中实现。该模式使子类可以不改变算法结构即可重定义算法的某些特定步骤。

## 核心思想

- 不变流程：父类定义算法骨架（模板方法）

- 可变细节：子类实现具体步骤的细节

- 原则：子类不调用父类，父类调用子类

### 模式结构
- **抽象类（Abstract Class）**：定义模板方法和算法的各个步骤。这些步骤可以是抽象的，也可以有默认实现。
- **具体类（Concrete Class）**：实现抽象类中的抽象步骤，覆盖某些步骤（如果需要）。
### C++23 实现示例
假设我们有一个游戏角色战斗的流程：
1. 准备战斗（准备武器、护甲等）
2. 执行战斗（不同的角色战斗方式不同）
3. 结束战斗（清理战场、恢复等）

### 代码说明

1. **抽象类 `战斗流程`**：
   - 定义了模板方法 `执行战斗流程()`，该方法按顺序调用三个步骤：`准备战斗()`、`执行战斗()`、`结束战斗()`。
   - 提供了`准备战斗`和`结束战斗`的默认实现，而`执行战斗`为纯虚函数，要求子类必须实现。
2. **具体类 `战士`**：
   - 实现了`执行战斗()`，使用近战攻击。
   - 没有重写其他步骤，因此使用基类的默认实现。
3. **具体类 `法师`**：
   - 重写了`准备战斗()`，因为法师需要准备法术书和魔杖。
   - 实现了`执行战斗()`，施放火球术。
   - 重写了`结束战斗()`，在基类行为的基础上增加了冥想恢复魔力。

### 运行结果
```
===== 战士的战斗流程 =====
角色正在准备武器和护甲...
战士使用剑进行近战攻击！
战斗结束，清理战场并恢复状态。
===== 法师的战斗流程 =====
法师正在准备法术书和魔杖...
法师施放火球术！
战斗结束，清理战场并恢复状态。
法师冥想以恢复魔力。
```

### 优点

1. 代码复用：公共流程在父类实现，避免重复
2. 扩展性强：新增角色只需继承并实现特定步骤
3. 流程控制：父类严格控制算法执行顺序
4. 符合开闭原则：修改子类不影响其他类

### 缺点

1. 每个不同的实现都需要一个子类，可能导致类数量增加。
2. 通过继承实现，父类对子类有较大影响，可能违反里氏替换原则（如果子类不正确地重写了方法）。

### 应用场景

- 当多个类有相同的行为，但具体实现不同时。
- 当需要控制子类扩展的步骤时（通过模板方法定义步骤顺序）。
在游戏开发中，模板方法模式常用于：
- 角色行为流程（如战斗、移动等）。
- 游戏状态管理（如进入状态、更新状态、退出状态）。
- 关卡流程（初始化关卡、更新关卡、结束关卡）。
通过模板方法模式，我们可以确保算法的结构不变，同时允许子类灵活地实现具体细节。
